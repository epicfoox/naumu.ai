<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>naumu</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@300;700&display=swap" rel="stylesheet">
  <link rel="icon" type="image/png" href="favicon.png">

  <style>
    /* CSS: The Visual Structure */
    :root {
      --mouse-x: 50%;
      --mouse-y: 50%;
      --tx: 0;
      --ty: 0;
    }

    body,
    html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      color: #000000;
      font-family: 'Comfortaa', sans-serif;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Dynamic Spotlight Background */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      /* Increased contrast for visibility */
      background: radial-gradient(circle at var(--mouse-x) var(--mouse-y), #ffffff 0%, #dbe0e8 100%);
      z-index: -3;
      pointer-events: none;
    }



    /* Knowledge Graph Canvas */
    #bg-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
    }

    .scene {
      perspective: 1000px;
      perspective-origin: center;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      /* Ensure scene is above the background */
      position: relative;
      z-index: 1;
    }

    .logo-wrapper {
      text-align: center;
      transform-style: preserve-3d;
      transform-origin: center center;
      will-change: transform;
      cursor: default;
      user-select: none;
      /* Entrance Animation removed to prevent conflict with tilt */
      opacity: 1;
    }

    h1 {
      font-size: 12vw;
      font-weight: 700;
      margin: 0;
      line-height: 0.9;
      letter-spacing: -0.05em;
      color: #1a1a1a;
      /* Entrance Animation */
      opacity: 0;
      animation: floatIn 1.2s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
      /* Dynamic Shadow for Depth */
      text-shadow:
        calc((var(--mouse-x) - 50%) * -30px) calc((var(--mouse-y) - 50%) * -30px) 30px rgba(0, 0, 0, 0.1);
      transition: text-shadow 0.1s ease;
    }

    p {
      font-size: 2.5vw;
      font-weight: 300;
      margin-top: 1vh;
      color: #555;
      letter-spacing: 0.05em;
      opacity: 0;
      /* Hidden initially for stagger effect */
      animation: floatIn 1.2s cubic-bezier(0.2, 0.8, 0.2, 1) 0.2s forwards;
    }

    @keyframes floatIn {
      0% {
        opacity: 0;
        transform: translateY(30px) translateZ(-50px);
      }

      100% {
        opacity: 1;
        transform: translateY(0) translateZ(0);
      }
    }

    /* Mobile Optimization */
    @media (max-width: 768px) {
      h1 {
        font-size: 18vw;
      }

      p {
        font-size: 5vw;
      }
    }

    /* Focus Mode */
    body.focused .scene,
    body.focused #bg-canvas {
      filter: blur(10px);
      opacity: 0.4;
      transition: all 0.5s ease;
    }

    body.focused .input-container {
      top: 50%;
      transform: translate(-50%, -50%);
      width: calc(100% - 48px);
      /* Ensure padding on mobile */
      max-width: 500px;
      box-shadow:
        0 30px 60px rgba(0, 0, 0, 0.12),
        0 0 0 1px rgba(0, 0, 0, 0.05),
        inset 0 1px 0 rgba(255, 255, 255, 0.6);
    }

    /* Mobile Focus Override: Prevent movement up, stick to bottom */
    @media (max-width: 768px) {
      body.focused .input-container {
        top: auto;
        bottom: calc(20px + env(safe-area-inset-bottom));
        transform: translateX(-50%);
      }
    }

    /* Result Modal */
    .result-modal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -60%) scale(0.95);
      /* Start slightly higher */
      width: calc(100% - 48px);
      /* Full width with padding */
      max-width: 600px;
      height: auto;
      max-height: 60vh;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 16px 20px;
      /* Tighter padding */
      border-radius: 32px;
      box-sizing: border-box;
      /* Ensure padding doesn't expand width */
      box-shadow:
        0 20px 40px -10px rgba(0, 0, 0, 0.1),
        0 0 0 1px rgba(0, 0, 0, 0.05),
        inset 0 1px 0 rgba(255, 255, 255, 0.6);
      opacity: 0;
      pointer-events: none;
      transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
      z-index: 90;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
    }

    .result-modal h2 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 700;
      color: #1a1a1a;
    }

    .result-modal p {
      margin: 0;
      font-size: 1rem;
      line-height: 1.6;
      color: #444;
      font-weight: 300;
    }

    /* Submitted State */
    body.submitted .result-modal {
      opacity: 1;
      transform: translate(-50%, -55%) scale(1);
      /* Centered vertically roughly */
      pointer-events: auto;
    }

    /* Override Focus State when Submitted */
    body.submitted .input-container {
      top: auto !important;
      bottom: calc(5vh + env(safe-area-inset-bottom)) !important;
      /* Move to bottom */
      transform: translateX(-50%) !important;
      width: calc(100% - 48px) !important;
      max-width: 420px !important;
    }

    /* Keep blur when submitted */
    body.submitted .scene,
    body.submitted #bg-canvas {
      filter: blur(10px);
      opacity: 0.4;
    }

    /* Floating Input Bar */
    .input-container {
      position: absolute;
      top: 65vh;
      /* Anchor from top to expand downwards */
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: flex-end;
      /* Align button to bottom */
      background: rgba(255, 255, 255, 0.8);
      /* More opaque */
      backdrop-filter: blur(20px);
      /* Stronger blur */
      -webkit-backdrop-filter: blur(20px);
      padding: 8px 8px 8px 24px;
      border-radius: 32px;
      /* Adjusted for multiline */
      /* Stronger shadow and border for contrast against white */
      box-shadow:
        0 20px 40px -10px rgba(0, 0, 0, 0.1),
        0 0 0 1px rgba(0, 0, 0, 0.05),
        inset 0 1px 0 rgba(255, 255, 255, 0.6);
      transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
      z-index: 100;
      width: 85%;
      max-width: 420px;
    }

    .input-container:focus-within {
      background: rgba(255, 255, 255, 0.95);
      /* More opaque on focus */
      /* transform is handled by body.focused rule */
    }

    .input-container textarea {
      border: none;
      background: transparent;
      outline: none;
      font-family: 'Comfortaa', sans-serif;
      font-size: 1rem;
      color: #1a1a1a;
      flex-grow: 1;
      padding: 10px 16px 10px 0;
      /* More right padding for scrollbar space */
      font-weight: 300;
      resize: none;
      overflow: hidden;
      min-height: 24px;
      max-height: 20vh;
      /* Limit height */
      line-height: 1.5;
      box-sizing: border-box;
      /* Fix auto-expand calculation */
    }

    .input-container textarea::placeholder {
      color: #666;
      opacity: 0.6;
      transition: opacity 0.2s;
    }

    .input-container:focus-within textarea::placeholder {
      opacity: 0.4;
    }

    /* Hide Scrollbar */
    .input-container textarea::-webkit-scrollbar {
      display: none;
    }

    .input-container textarea {
      -ms-overflow-style: none;
      /* IE and Edge */
      scrollbar-width: none;
      /* Firefox */
    }

    .input-container button {
      background: #1a1a1a;
      border: none;
      border-radius: 50%;
      width: 42px;
      height: 42px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
      flex-shrink: 0;
    }

    .input-container button:hover {
      transform: scale(1.05);
      background: #000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .input-container button:active {
      transform: scale(0.95);
    }

    .input-container button svg {
      width: 20px;
      height: 20px;
      stroke-width: 2.5px;
    }
  </style>
</head>

<body>

  <canvas id="bg-canvas"></canvas>
  <div class="scene" id="scene">
    <div class="logo-wrapper" id="target">
      <h1>naumu</h1>
      <p>ideas, structured.</p>
    </div>
  </div>

  <div class="result-modal">
    <h2>Here is your knowledge chart</h2>
    <p>
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore
      magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
      consequat.
    </p>
    <p>
      Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur
      sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
    </p>
  </div>

  <div class="input-container">
    <textarea placeholder="What's on your mind?" id="topic-input" rows="1"></textarea>
    <button id="submit-btn" aria-label="Start learning">
      <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M5 12H19M19 12L12 5M19 12L12 19" stroke="currentColor" stroke-linecap="round"
          stroke-linejoin="round" />
      </svg>
    </button>
  </div>

  <script>
    /* JS: The Interactive Behavior */
    const target = document.getElementById('target');
    const root = document.documentElement;

    // Configuration
    const inputIntensity = 35; // Intensity of mouse/touch tilt
    const autoIntensity = 5; // Intensity of the constant circular motion
    const autoSpeed = 0.000005; // Speed of the circular motion

    // State
    let inputX = 0; // Current smoothed X
    let inputY = 0; // Current smoothed Y
    let targetInputX = 0; // Target X from mouse/touch
    let targetInputY = 0; // Target Y from mouse/touch

    // Gyro State
    let gyroX = 0;
    let gyroY = 0;
    let targetGyroX = 0;
    let targetGyroY = 0;
    let initialBeta = null;
    let initialGamma = null;

    let time = 0;

    function handleMove(x, y) {
      // Use clientWidth/Height to exclude scrollbars and get accurate visual viewport
      const w = document.documentElement.clientWidth || window.innerWidth;
      const h = document.documentElement.clientHeight || window.innerHeight;

      // Calculate percentages for CSS variables (Lighting/Background)
      const xPercent = (x / w) * 100;
      const yPercent = (y / h) * 100;

      root.style.setProperty('--mouse-x', `${xPercent}%`);
      root.style.setProperty('--mouse-y', `${yPercent}%`);

      // Calculate normalized position (-1 to 1)
      // Update TARGET values for smoothing
      targetInputX = (x - (w / 2)) / (w / 2);
      targetInputY = (y - (h / 2)) / (h / 2);
    }

    function resetInput() {
      targetInputX = 0;
      targetInputY = 0;
      root.style.setProperty('--mouse-x', '50%');
      root.style.setProperty('--mouse-y', '50%');
    }

    // --- Knowledge Graph Background Animation (3D) ---
    const canvas = document.getElementById('bg-canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    let cx, cy; // Center of screen

    // Graph State
    const nodes = [];
    const edges = [];
    const maxNodes = 120; // Increased to allow more spread
    const spawnInterval = 50; // Faster spawn (50ms)
    let lastSpawnTime = 0;

    // 3D Configuration
    const focalLength = 800; // Perspective strength
    const rotationStrength = 0.05; // Much more subtle rotation (0.5 -> 0.05)

    class Node {
      constructor(x, y, z, parent = null) {
        // Position relative to center (0,0,0)
        this.x = x;
        this.y = y;
        this.z = z;
        this.parent = parent;

        this.radius = Math.random() * 2 + 2; // 2-4px

        // 3D Velocity
        this.vx = (Math.random() - 0.5) * 0.5;
        this.vy = (Math.random() - 0.5) * 0.5;
        this.vz = (Math.random() - 0.5) * 0.5;

        this.opacity = 0; // Start invisible
      }

      update() {
        // Drift in 3D
        this.x += this.vx;
        this.y += this.vy;
        this.z += this.vz;

        // Soft bounds (bounce back if too far)
        const limit = 1000;
        if (Math.abs(this.x) > limit) this.vx *= -1;
        if (Math.abs(this.y) > limit) this.vy *= -1;
        if (Math.abs(this.z) > limit) this.vz *= -1;

        // Fade in
        if (this.opacity < 1) {
          this.opacity += 0.02; // Faster fade
        }
      }
    }

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      cx = width / 2;
      cy = height / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    // Initialize with 4 corner clusters
    function initGraph() {
      nodes.length = 0;
      edges.length = 0;

      const corners = [
        { x: -width / 2, y: -height / 2 },
        { x: width / 2, y: -height / 2 },
        { x: width / 2, y: height / 2 },
        { x: -width / 2, y: height / 2 }
      ];

      corners.forEach(c => {
        // Root
        const root = new Node(c.x, c.y, 0);
        nodes.push(root);

        // Create 2 neighbors immediately to avoid single dot look
        for (let i = 0; i < 2; i++) {
          const dist = Math.random() * 100 + 50;
          const angleToCenter = Math.atan2(-c.y, -c.x);
          const theta = angleToCenter + (Math.random() - 0.5) * 1.5;
          const phi = Math.acos((Math.random() * 2) - 1);

          const nx = root.x + dist * Math.sin(phi) * Math.cos(theta);
          const ny = root.y + dist * Math.sin(phi) * Math.sin(theta);
          const nz = root.z + dist * Math.cos(phi);

          const neighbor = new Node(nx, ny, nz, root);
          nodes.push(neighbor);
          edges.push({ from: root, to: neighbor });
        }
      });

      lastSpawnTime = Date.now();
    }
    initGraph();

    function updateGraph() {
      const now = Date.now();

      // Spawn new node
      if (nodes.length < maxNodes && now - lastSpawnTime > spawnInterval) {
        const parentNode = nodes[Math.floor(Math.random() * nodes.length)];

        let attempts = 0;
        let placed = false;

        while (attempts < 10 && !placed) {
          // Smaller distance for "slow" spread
          const dist = Math.random() * 150 + 50;

          // Bias angle towards center (0,0)
          const angleToCenter = Math.atan2(-parentNode.y, -parentNode.x);
          // Spread of +/- 60 degrees (approx 1 radian) around the vector to center
          const theta = angleToCenter + (Math.random() - 0.5) * 3;

          const phi = Math.acos((Math.random() * 2) - 1); // Random Polar angle

          const newX = parentNode.x + dist * Math.sin(phi) * Math.cos(theta);
          const newY = parentNode.y + dist * Math.sin(phi) * Math.sin(theta);
          const newZ = parentNode.z + dist * Math.cos(phi);

          // Exclusion Zone: Cylinder along Z axis
          // Keep center clear of nodes (radius 250px)
          const r = Math.sqrt(newX * newX + newY * newY);
          if (r > 250) {
            const newNode = new Node(newX, newY, newZ, parentNode);
            nodes.push(newNode);
            edges.push({ from: parentNode, to: newNode });
            lastSpawnTime = now;
            placed = true;
          }
          attempts++;
        }
      }

      // Update nodes
      nodes.forEach(node => node.update());
    }

    function project(x, y, z, rotX, rotY) {
      // 1. Rotate around Y axis (Yaw) - controlled by Mouse X
      // x' = x cos θ + z sin θ
      // z' = -x sin θ + z cos θ
      let x1 = x * Math.cos(rotY) + z * Math.sin(rotY);
      let z1 = -x * Math.sin(rotY) + z * Math.cos(rotY);
      let y1 = y;

      // 2. Rotate around X axis (Pitch) - controlled by Mouse Y
      // y' = y cos φ - z' sin φ
      // z'' = y sin φ + z' cos φ
      let y2 = y1 * Math.cos(rotX) - z1 * Math.sin(rotX);
      let z2 = y1 * Math.sin(rotX) + z1 * Math.cos(rotX);
      let x2 = x1;

      // 3. Project to 2D
      // scale = f / (f + z)
      // We push z back by some amount so we don't divide by zero or get negative depth issues
      // Camera is at z = -focalLength
      const scale = focalLength / (focalLength + z2 + 500);

      return {
        x: x2 * scale + cx,
        y: y2 * scale + cy,
        scale: scale,
        z: z2 // Return depth for sorting if needed (not needed for simple lines)
      };
    }

    function drawGraph() {
      ctx.clearRect(0, 0, width, height);

      // Calculate rotation based on input
      // inputX/Y are -1 to 1.
      const rotY = inputX * rotationStrength; // Yaw
      const rotX = -inputY * rotationStrength; // Pitch

      // Project all nodes first
      const projectedNodes = nodes.map(node => {
        const p = project(node.x, node.y, node.z, rotX, rotY);
        return { ...p, node };
      });

      // Draw Edges
      ctx.lineWidth = 1.5;
      edges.forEach(edge => {
        // Find projected positions
        const p1 = projectedNodes.find(p => p.node === edge.from);
        const p2 = projectedNodes.find(p => p.node === edge.to);

        if (p1 && p2) {
          const edgeOpacity = Math.min(edge.from.opacity, edge.to.opacity) * 0.15;
          ctx.strokeStyle = `rgba(136, 146, 176, ${edgeOpacity})`;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      });

      // Draw Nodes
      projectedNodes.forEach(p => {
        ctx.beginPath();
        // Scale radius by perspective
        const r = Math.max(0.5, p.node.radius * p.scale);
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(136, 146, 176, ${p.node.opacity})`;
        ctx.fill();
      });
    }
    // --------------------------------------------

    // Animation Loop
    function update() {
      time += autoSpeed;

      // Smoothly interpolate current input towards target input (Lerp)
      // 0.1 = 10% of the distance per frame (adjust for speed/smoothness)
      inputX += (targetInputX - inputX) * 0.1;
      inputY += (targetInputY - inputY) * 0.1;

      // Smoothly interpolate gyro input
      gyroX += (targetGyroX - gyroX) * 0.1;
      gyroY += (targetGyroY - gyroY) * 0.1;

      // Calculate Auto-Tilt (Circular Motion)
      const autoRotateX = Math.sin(time * 1000) * autoIntensity;
      const autoRotateY = Math.cos(time * 1000) * autoIntensity;

      // Calculate Input Tilt (Mouse/Touch)
      // Mouse Right (Positive X) -> Rotate Y Positive
      // Mouse Down (Positive Y) -> Rotate X Negative
      const inputRotateY = inputX * inputIntensity;
      const inputRotateX = -inputY * inputIntensity;

      // Calculate Gyro Tilt
      const gyroRotateY = gyroX * inputIntensity;
      const gyroRotateX = -gyroY * inputIntensity;

      // Combine them (Auto + Input + Gyro)
      const finalRotateX = inputRotateX + autoRotateX + gyroRotateX;
      const finalRotateY = inputRotateY + autoRotateY + gyroRotateY;

      // Apply Transform
      target.style.transform = `rotateX(${finalRotateX}deg) rotateY(${finalRotateY}deg)`;

      // Update Parallax Background (Input + Gyro)
      root.style.setProperty('--tx', inputX + gyroX);
      root.style.setProperty('--ty', inputY + gyroY);

      // Update and Draw Graph
      updateGraph();
      drawGraph();

      requestAnimationFrame(update);
    }

    // Start the loop
    update();

    // Mouse Events
    document.addEventListener('mousemove', (event) => {
      handleMove(event.clientX, event.clientY);
    });

    document.addEventListener('mouseleave', resetInput);

    // Touch Events
    document.addEventListener('touchstart', (event) => {
      // Allow interaction with inputs, textareas, and buttons
      if (event.target.closest('input, textarea, button')) return;

      event.preventDefault(); // Prevent mouse emulation and scrolling
      const touch = event.touches[0];
      handleMove(touch.clientX, touch.clientY);
    }, { passive: false });

    document.addEventListener('touchmove', (event) => {
      // Allow interaction with inputs, textareas, and buttons
      if (event.target.closest('input, textarea, button')) return;

      event.preventDefault(); // Prevent scrolling while interacting
      const touch = event.touches[0];
      handleMove(touch.clientX, touch.clientY);
    }, { passive: false });

    document.addEventListener('touchend', resetInput);

    // Device Orientation (Gyroscope)
    window.addEventListener('deviceorientation', (event) => {
      // Beta: Front-to-back tilt (-180 to 180)
      // Gamma: Left-to-right tilt (-90 to 90)
      const beta = event.beta;
      const gamma = event.gamma;

      if (beta === null || gamma === null) return;

      // Set initial state on first reading
      if (initialBeta === null) {
        initialBeta = beta;
        initialGamma = gamma;
      }

      // Calculate difference from initial position
      let deltaBeta = beta - initialBeta;
      let deltaGamma = gamma - initialGamma;

      // Clamp values to avoid extreme rotations (e.g., +/- 30 degrees)
      const maxTilt = 30;
      deltaBeta = Math.max(-maxTilt, Math.min(maxTilt, deltaBeta));
      deltaGamma = Math.max(-maxTilt, Math.min(maxTilt, deltaGamma));

      // Normalize to -1 to 1 range
      // Note: Gamma (Left/Right) maps to X axis input
      // Note: Beta (Up/Down) maps to Y axis input
      // Inverted signs so the logo looks towards the user when tilting
      targetGyroX = -(deltaGamma / maxTilt);
      targetGyroY = -(deltaBeta / maxTilt);
    });

    // iOS 13+ Permission Request
    function requestGyroPermission() {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === 'granted') {
              // Permission granted
            }
          })
          .catch(console.error);
      }
    }

    // Trigger permission request on first interaction (Capture phase to ensure it runs)
    document.addEventListener('click', requestGyroPermission, { once: true, capture: true });
    document.addEventListener('touchstart', requestGyroPermission, { once: true, capture: true });

    // Auto-expand Textarea
    const textarea = document.getElementById('topic-input');
    const inputContainer = document.querySelector('.input-container');

    // Focus Mode Logic
    textarea.addEventListener('focus', () => {
      // Delay to prevent immediate dismissal if events overlap
      setTimeout(() => {
        document.body.classList.add('focused');
      }, 100);
    });

    // Dismiss Focus Logic
    function dismissFocus(e) {
      // If we are not focused, do nothing
      if (!document.body.classList.contains('focused')) return;

      if (!e.target.closest('.input-container')) {
        document.body.classList.remove('focused');
        textarea.blur();
      }
    }

    // Click anywhere else to dismiss
    document.addEventListener('click', dismissFocus);
    // Touch anywhere else to dismiss (for mobile)
    document.addEventListener('touchstart', dismissFocus);

    // Submission Logic
    const submitBtn = document.getElementById('submit-btn');

    function handleSubmit() {
      document.body.classList.add('submitted');
      textarea.value = ''; // Clear input
      textarea.style.height = 'auto'; // Reset height
      textarea.blur();
    }

    submitBtn.addEventListener('click', handleSubmit);

    textarea.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSubmit();
      }
    });

    // Close modal on click/touch away
    function closeModal(e) {
      if (document.body.classList.contains('submitted')) {
        // If clicked outside modal and input container
        if (!e.target.closest('.result-modal') && !e.target.closest('.input-container')) {
          document.body.classList.remove('submitted');
          document.body.classList.remove('focused'); // Also remove focus state
        }
      }
    }

    document.addEventListener('click', closeModal);
    document.addEventListener('touchstart', closeModal);

    textarea.addEventListener('input', function () {
      this.style.height = 'auto';
      this.style.height = (this.scrollHeight) + 'px';

      // Toggle overflow based on max-height
      if (this.scrollHeight > this.clientHeight) {
        this.style.overflowY = 'auto';
      } else {
        this.style.overflowY = 'hidden';
      }
    });
  </script>
</body>

</html>